var documenterSearchIndex = {"docs":
[{"location":"tutorials/#Tutorial","page":"Simple example","title":"Tutorial","text":"","category":"section"},{"location":"tutorials/","page":"Simple example","title":"Simple example","text":"We show here a very basic simulation where we apply a glutamate pulse to the postsynaptic side.","category":"page"},{"location":"tutorials/","page":"Simple example","title":"Simple example","text":"using Plots, SynapseElife\nusing Sundials, LSODA # ODE solvers\n# we load this package to simulate this particular class of Markov processes\nusing PiecewiseDeterministicMarkovProcesses\n\n# this holds the spine parameters\n# we change the simulation time parameter\nparam_synapse = SynapseParams(t_end = 1000.)\n\n# initial conditions for the spine\n# initial conditions deterministic vars\nxc0 = initial_conditions_continuous_temp(param_synapse)\n# initial conditions stochastic channels\nxd0 = initial_conditions_discrete(param_synapse)\n\n# we put a presynaptic pulse at 500ms, actually we put a glutamate pulse.\nevents_times = [500.]\n# we say that this is a pre-synaptic simulation. \n# If we put `false`, it would be a post-synaptic stimulus\nis_pre_or_post_event = [true]\n\n# ODE time stepper\node = :lsoda\node = CVODE_BDF()\n\n# simulate the spine dynamics\nresult = @time evolveSynapse(\n\t\txc0,\n\t\txd0,\n\t\tparam_synapse,\n\t\tevents_times,\t\t\t# external events\n\t\tis_pre_or_post_event,\t# pre or post?\n\t\tFloat64[],\t\t\t# auxiliary BaP, empty list\n\t\t[true],\t\t\t\t# whether the pre-synaptic event leads to Glu release\n\t\t(CHV(ode), CHV(ode));\n\t\tsave_positions = (false, true) # we want to record only the post-jump values\n\t\t)\nnothing #hide","category":"page"},{"location":"tutorials/","page":"Simple example","title":"Simple example","text":"We can for example plot all the discrete variables","category":"page"},{"location":"tutorials/","page":"Simple example","title":"Simple example","text":"# plot the discrete variables\nSynapseElife.plot_discrete(result.t, result.XC, result.XD)","category":"page"},{"location":"tutorials/","page":"Simple example","title":"Simple example","text":"We can also select a specific variable to be printed:","category":"page"},{"location":"tutorials/","page":"Simple example","title":"Simple example","text":"# plot specific variable\nSynapseElife.plot_variable(result.t, result.XC, result.XD, :Vsp; xlim = (480., 520))","category":"page"},{"location":"figure1/#Figure-1","page":"Figure 1","title":"Figure 1","text":"","category":"section"},{"location":"figure1/","page":"Figure 1","title":"Figure 1","text":"The goal of this page is to reproduce the Figure 1 in BiorXiv. Note that this is essentially the file in example/Figure1.jl. ","category":"page"},{"location":"figure1/","page":"Figure 1","title":"Figure 1","text":"This page is auto-generated in part to show that the provided code is working.","category":"page"},{"location":"figure1/","page":"Figure 1","title":"Figure 1","text":"using SynapseElife,\n\tRandom,\n\tPlots,\n\tPiecewiseDeterministicMarkovProcesses,\n\tColorSchemes, Sundials\n\ndata_protocol = dataProtocol(\"TigaretMellor16\")","category":"page"},{"location":"figure1/","page":"Figure 1","title":"Figure 1","text":"Let us now define a synapse model corresponding to a protocol and the initial state of the synapse","category":"page"},{"location":"figure1/","page":"Figure 1","title":"Figure 1","text":"k = 8\npls = 1\nstart = 0.5e3\n\n##### STIMULI EVENT REPRESENTATION\nevents_times, is_pre_or_post_event = firingPattern(\n\t\t\tstart_time=start,\n\t\t\tn_pos  \t\t = data_protocol[!,:n_pos][k],\n\t\t\tdelay_pos\t = data_protocol[!,:delay_pos][k],\n\t\t\tn_pre  \t\t = data_protocol[!,:n_pre][k],\n\t\t\tdelay_pre\t = data_protocol[!,:delay_pre][k],\n\t\t\tdelay  \t\t = data_protocol[!,:delay][k],\n\t\t\tpulse  \t\t = pls, #data_protocol[:pulse][k],\t\t# PULSE\n\t\t\tfreq   \t\t = data_protocol[!,:freq][k],\t\t\t# FREQUENCY\n\t\t\tcausal \t\t = data_protocol[!,:causal][k],\n\t\t\trepeat_times = data_protocol[!,:repeat_times][k],\t# FREQUENCY\n\t\t\trepeat_after = data_protocol[!,:repeat_after][k])\n\nif data_protocol[!,:post_poisson_rate][k] > 0\n\t # for Poisson, mandatory positive rate, \n\t # the regular rate in the parameters is used \n\t # to set the event_time end\n\tpost = SynapseElife.PoissonProcess(data_protocol[!,:post_poisson_rate][k], start, events_times[end] )\n\t\tpost_ = repeat([0],inner=length(post))\n\tpre = SynapseElife.PoissonProcess(data_protocol[!,:pre_poisson_rate][k], start, events_times[end] )\n\t\tpre_ = repeat([0],inner=length(pre))\n\tevents_times=[pre;post]\n\tp=sortperm(events_times)\n\tglobal is_pre_or_post_event=[pre_;post_][p]\n\tglobal events_times=[pre;post][p]\nend\n\nparam_synapse = SynapseParams(\n\t\t\tt_end\t\t   = start+(data_protocol[!,:repeat_times][k]+1)*pls*1000/data_protocol[!,:freq][k]+.7e3,\n\t\t\tsoma_dist \t\t= 200. ,\n\t\t\ttemp_rates \t\t= data_protocol[!,:temp][k],\n\t\t\tCa_ext\t\t\t= data_protocol[!,:exca][k],\n\t\t\tMg\t\t\t\t= data_protocol[!,:exmg][k],\n\t\t\tage\t\t\t\t= data_protocol[!,:age][k],\n\t\t\tinjbap\t\t\t= data_protocol[!,:inj_time][k],\n\t\t\tI_clamp\t\t\t= data_protocol[!,:injection][k],\n\t\t\tsampling_rate   = 10.)\n\np = param_synapse.p_release\npre_synapse = PreSynapseParams(h = 0) # A zero is placed here since we don't want to have a release failure when showing panel B in Figure 1.\n\nxc0 = initial_conditions_continuous_temp(param_synapse) # initial conditions deterministic vars\nxd0 = initial_conditions_discrete(param_synapse)        # initial conditions stochastic channels\n\nnothing #hide","category":"page"},{"location":"figure1/","page":"Figure 1","title":"Figure 1","text":"We now run the pre-synaptic model corresponding to the stimulus","category":"page"},{"location":"figure1/","page":"Figure 1","title":"Figure 1","text":"is_glu_release, Docked, Reserve, t_stp, glu_release_times, bap_by_epsp_times = stp(param_synapse.t_end, pre_synapse, events_times, is_pre_or_post_event, _plot = false, algo = CHV(CVODE_BDF()))\n@info \"number of releases $(sum(is_glu_release))\"","category":"page"},{"location":"figure1/","page":"Figure 1","title":"Figure 1","text":"Run the synapse model","category":"page"},{"location":"figure1/","page":"Figure 1","title":"Figure 1","text":"Random.seed!(7)\nresult = @time evolveSynapse(\n\txc0, xd0,\n\tparam_synapse,\n\tevents_times[events_times .< param_synapse.t_end],\n\tis_pre_or_post_event,\n\tifelse(data_protocol[!,:AP_by_EPSP][k] == \"yes\", bap_by_epsp_times, Float64[]), #optional BaP induced by EPSP\n\tis_glu_release,\n\t(CHV(CVODE_BDF(linear_solver=:GMRES)), CHV(CVODE_BDF(linear_solver=:GMRES)));\n\t# (CHV(:lsoda), CHV(:lsoda));\n\tabstol = 1e-6, reltol = 1e-5,\n\tsave_positions = (false, true),\n\tverbose = true) # model function 0.25s\n\n\ntt = result.t\nXD = result.XD\n\ncolorss = ColorSchemes.viridis\nlimits_d(x) = (minimum(x) ;maximum(x))\nnothing #hide","category":"page"},{"location":"figure1/","page":"Figure 1","title":"Figure 1","text":"Finally, let's plot the first panel","category":"page"},{"location":"figure1/","page":"Figure 1","title":"Figure 1","text":"l = @layout [[a{.5w} b{.3w}]; [c{.5w}  d{.3w}]; [e{.5w} f{.3w}]; [g{.5w} h{.3w}]]\nPlots.plot(windowsize=(1.5*700 * .6,350*1.5),layout=l,grid=false)\n\n#AMPAr\nlim=[(start-15*.02),(start+15*.28)]\nval = XD[14,:] .+ XD[15,:] .+ XD[16,:]\nplot!(tt,val,xlabel=\" \",label=\"\",ylabel=\"AMPAr\",w=2.5,subplot=1,alpha=1,color=get(colorss, 0.) ,linetype=:steppost,layout=l,axis=false,grid=false,xlim=[start-20 ,start .+ 250],xticks=(collect(500:100:700),collect(0:100:200))\n,yticks=(collect(0:20:80)))\nplot!(tt,val,xlabel=\"time (ms)\",label=\"\",ylabel=\"AMPAr\",w=2.5,subplot=2,alpha=1,color=get(colorss, 0.) ,linetype=:steppost,layout=l,xlim=lim,\nxticks=(collect(500:1:504),collect(0:1:4)),\nyticks=(collect(0:20:80)))\n\n#VGCC\nlim = [(start+11.2),(start+20)]\nval = XD[28,:]\nplot!(tt,XD[32,:],xlabel=\"\",label=\"T-type\",ylabel=\"\",w=2.5,subplot=3,alpha=1,color=get(colorss, .5) ,linetype=:steppost,layout=l)\nplot!(tt,XD[28,:],xlabel=\"\",label=\"R-type\",ylabel=\"\",w=2.5,subplot=3,alpha=1,color=get(colorss, 1.) ,linetype=:steppost,layout=l,axis=false,grid=false)\nplot!(tt,XD[34,:] .+ XD[35,:],xlabel=\"\",label=\"L-type\",ylabel=\"VGCC\",w=2.5,subplot=3,alpha=1,color=get(colorss, .0) ,linetype=:steppost,layout=l,\nxlim=[start-20 ,start .+ 250],xticks=(collect(500:100:700),collect(0:100:200)))\n\nplot!(tt,XD[28,:],xlabel=\"\",label=\"\",ylabel=\"\",w=2.5,subplot=4,alpha=1,color=get(colorss, 1.) ,linetype=:steppost,layout=l)\nplot!(tt,XD[32,:],xlabel=\"\",label=\"\",ylabel=\"\",w=2.5,subplot=4,alpha=1,color=get(colorss, .5) ,linetype=:steppost,layout=l)\nplot!(tt,XD[34,:] .+ XD[35,:],xlabel=\"time (ms)\",label=\"\",ylabel=\"VGCC\",w=2.5,subplot=4,alpha=1,color=get(colorss, .0) ,linetype=:steppost,layout=l,xlim=lim,\nxticks=(collect(512:2:520),collect(0:2:8)))\n\n#GABAr\nlim = [(start-100*.015),(start+100*.3)]\nval = XD[49,:] .+ XD[50,:]\nplot!(tt,val,xlabel=\"\",label=\"\",ylabel=\"GABAr\",w=2.5,subplot=5,alpha=1,color=get(colorss, 0.5) ,linetype=:steppost,layout=l,axis=false,grid=false,\nxlim=[start-20 ,start .+ 250],xticks=(collect(500:100:700),collect(0:100:200)))\nplot!(tt,val,xlabel=\"time (ms)\",label=\"\",ylabel=\"GABAr\",w=2.5,subplot=6,alpha=1,color=get(colorss, 0.5) ,linetype=:steppost,layout=l,\nxlim=lim,\nxticks=(collect(500:10:530),collect(0:10:30)),yticks=(collect(0:10:30)))\n\n#NMDAr\nlim = [(start-550*.06 ),(start+550 )]\nval = XD[22,:] .+ XD[23,:]\nplot!(tt,val,xlabel=\"\",label=\"GluN2A\",ylabel=\"\",w=2.5,subplot=7,alpha=1,color=get(colorss, 0.25) ,linetype=:steppost,layout=l,yaxis=false,grid=false,xlim=[start-20,start .+ 250])\nplot!(tt,val,xlabel=\"time (ms)\",label=\"\",ylabel=\"NMDAr\",w=2.5,subplot=8,alpha=1,color=get(colorss, 0.25) ,linetype=:steppost,layout=l,xlim=[500-5,600],\nxticks=(collect(500:25:600),collect(0:25:100)),yticks=(collect(0:2:8)))\nval = XD[44,:] .+ XD[45,:]\nplot!(tt,val,xlabel=\"time (ms)\",label=\"GluN2B\",ylabel=\"NMDAr\",w=2.5,subplot=7,alpha=1,color=get(colorss, 0.75) ,linetype=:steppost,layout=l,\nxticks=(collect(500:100:700),collect(0:100:200)),yticks=(collect(0:2:8)))","category":"page"},{"location":"figure1/","page":"Figure 1","title":"Figure 1","text":"Let's plot the second panel","category":"page"},{"location":"figure1/","page":"Figure 1","title":"Figure 1","text":"l = @layout [[a{.5w} b{.5w}]; [c{.5w}  d{.5w}]]\nPlots.plot(windowsize=(1.5*700 * .6,350*1),layout=l,grid=false)\n\nk = 8\npls = 1\nstart = .5e3\n\n#####EVENT REPRESENTATION\nevents_times, is_pre_or_post_event = firingPattern(\n\t\t\tstart_time=start,\n\t\t\tn_pos  \t\t = data_protocol[!,:n_pos][k],\n\t\t\tdelay_pos\t = data_protocol[!,:delay_pos][k],\n\t\t\tn_pre  \t\t = data_protocol[!,:n_pre][k],\n\t\t\tdelay_pre\t = data_protocol[!,:delay_pre][k],\n\t\t\tdelay  \t\t = data_protocol[!,:delay][k],\n\t\t\tpulse  \t\t = pls,#data_protocol[:pulse][k],\t\t# PULSE\n\t\t\tfreq   \t\t = data_protocol[!,:freq][k],\t\t\t# FREQUENCY\n\t\t\tcausal \t\t = data_protocol[!,:causal][k],\n\t\t\trepeat_times = data_protocol[!,:repeat_times][k],\t# FREQUENCY\n\t\t\trepeat_after = data_protocol[!,:repeat_after][k])\n\nparam_synapse = SynapseParams(\n\t\t\tt_end\t\t   = start+(data_protocol[!,:repeat_times][k]+1)*pls*1000/data_protocol[!,:freq][k]+2e3,\n\t\t\tsoma_dist \t\t= 200. ,\n\t\t\ttemp_rates \t\t= data_protocol[!,:temp][k],\n\t\t\tCa_ext\t\t\t= data_protocol[!,:exca][k],\n\t\t\tMg\t\t\t\t= data_protocol[!,:exmg][k],\n\t\t\tage\t\t\t\t= data_protocol[!,:age][k],\n\t\t\tinjbap\t\t\t= data_protocol[!,:inj_time][k],\n\t\t\tI_clamp\t\t\t= data_protocol[!,:injection][k],\n\t\t\tsampling_rate   = 0.1)\n\np = param_synapse.p_release\npre_synapse = PreSynapseParams(h = 0)\n\n\nxc0 = initial_conditions_continuous_temp(param_synapse)\nxd0 = initial_conditions_discrete(param_synapse)\n\n#####RUN MODEL\nis_glu_release, Docked, Reserve, t_stp, glu_release_times, bap_by_epsp_times = stp(param_synapse.t_end, pre_synapse, events_times, is_pre_or_post_event, algo = CHV(CVODE_BDF()))\n@show \"number of releases $(sum(is_glu_release))\"\n\n\nfor I in 1:5\n\tresult = @time evolveSynapse(\n\t\txc0,\n\t\txd0,\n\t\tparam_synapse,\n\t\tevents_times[events_times .< param_synapse.t_end],\n\t\tis_pre_or_post_event,\n\t\tifelse(data_protocol[!,:AP_by_EPSP][k] == \"yes\",bap_by_epsp_times,Float64[]), #optional BaP induced by EPSP\n\t\tis_glu_release,\n\t\t# (CHV(:lsoda), CHV(:lsoda));\n\t\t(CHV(CVODE_BDF(linear_solver=:GMRES)), CHV(CVODE_BDF(linear_solver=:GMRES)));\n\t\tabstol = 1e-6, reltol = 1e-5,\n\t\tsave_positions = (false, true),\n\t\tverbose = false) # model function\n\n\n\ttt = result.t\n\tout = SynapseElife.get_names(result.XC, result.XD)\n\n\targs = (color = :black, label = \"\", xlabel=\"time (ms)\", xlim = [470, 570],alpha=.3,w=2,xticks=(collect(500:25:550),collect(0:25:50)))\n\tplot!(tt, out[:Vsp]; subplot = 1, ylabel = \"Voltage (mv)\", args...)\n\tplot!(tt,  out[:Ca];  subplot = 2, ylabel = \"Ca2+ (μM)\", args...) |> display\nend\n\nk = 8\npls = 30\nstart = .5e3\n\n#####EVENT REPRESENTATION\nevents_times, is_pre_or_post_event = firingPattern(\n\t\t\tstart_time=start,\n\t\t\tn_pos  \t\t = data_protocol[!,:n_pos][k],\n\t\t\tdelay_pos\t = data_protocol[!,:delay_pos][k],\n\t\t\tn_pre  \t\t = data_protocol[!,:n_pre][k],\n\t\t\tdelay_pre\t = data_protocol[!,:delay_pre][k],\n\t\t\tdelay  \t\t = data_protocol[!,:delay][k],\n\t\t\tpulse  \t\t = pls,#data_protocol[:pulse][k],\t\t# PULSE\n\t\t\tfreq   \t\t = data_protocol[!,:freq][k],\t\t\t# FREQUENCY\n\t\t\tcausal \t\t = data_protocol[!,:causal][k],\n\t\t\trepeat_times = data_protocol[!,:repeat_times][k],\t# FREQUENCY\n\t\t\trepeat_after = data_protocol[!,:repeat_after][k])\n\nparam_synapse = SynapseParams(\n\t\t\tt_end\t\t   = start+(data_protocol[!,:repeat_times][k]+1)*pls*1000/data_protocol[!,:freq][k]+2e3,\n\t\t\tsoma_dist \t\t= 200. ,\n\t\t\ttemp_rates \t\t= data_protocol[!,:temp][k],\n\t\t\tCa_ext\t\t\t= data_protocol[!,:exca][k],\n\t\t\tMg\t\t\t\t= data_protocol[!,:exmg][k],\n\t\t\tage\t\t\t\t= data_protocol[!,:age][k],\n\t\t\tinjbap\t\t\t= data_protocol[!,:inj_time][k],\n\t\t\tI_clamp\t\t\t= data_protocol[!,:injection][k],\n\t\t\tsampling_rate   = 0.1)\n\np = param_synapse.p_release\npre_synapse = PreSynapseParams(h = (p[4]+ p[3]/(1+exp(p[1]* (data_protocol[!,:exca][k]-p[2])))))\n\nxc0 = initial_conditions_continuous_temp(param_synapse)\nxd0 = initial_conditions_discrete(param_synapse)\n\n#####RUN MODEL\nis_glu_release, Docked, Reserve, t_stp, glu_release_times, bap_by_epsp_times = stp(param_synapse.t_end, pre_synapse, events_times, is_pre_or_post_event, _plot = false, algo = CHV(CVODE_BDF()))\n@show \"number of releases $(sum(is_glu_release))\"\n\nplot!(t_stp/1000, Docked; label = \"docked\",subplot = 3,xlabel=\"time(s)\", ylabel = \"Vesicles\",linetype=:steppost ,w=2)\nplot!(t_stp/1000, Reserve; label = \"reserve\",subplot = 3,xlabel=\"time(s)\", ylabel = \"Vesicles\",linetype=:steppost ,w=2)\nscatter!(glu_release_times/1000, 31 .* ones(length(glu_release_times)); label = \"releases\",subplot = 3,xlabel=\"time (s)\", ylabel = \"Vesicles\",w=2)\n\nresult = @time evolveSynapse(\n\t\txc0,\n\t\txd0,\n\t\tparam_synapse,\n\t\tevents_times[events_times .< param_synapse.t_end],\n\t\tis_pre_or_post_event,\n\t\tifelse(data_protocol[!,:AP_by_EPSP][k] == \"yes\",bap_by_epsp_times,Float64[]), #optional BaP induced by EPSP\n\t\tis_glu_release,\n\t\t(CHV(CVODE_BDF(linear_solver=:GMRES)), CHV(CVODE_BDF(linear_solver=:GMRES)));\n\t\tabstol = 1e-6, reltol = 1e-5,\n\t\tsave_positions = (false, true),\n\t\tverbose = false, progress = true) # model function\n\ntt = result.t\nout = SynapseElife.get_names(result.XC, result.XD)\n\nargs = (color = :black, label = \"\", xlabel=\"time (s)\", w=2 )\nplot!(tt/1000, out[:λ]; subplot = 4, ylabel = \"BaP efficiency \", args...)","category":"page"},{"location":"figure1/","page":"Figure 1","title":"Figure 1","text":"And the last panel:","category":"page"},{"location":"figure1/","page":"Figure 1","title":"Figure 1","text":"l = @layout [a ; b ; c]\nPlots.plot(windowsize=(1*500, 1*400),layout=l,grid=false)\n\nk = 8\npls = 30\nstart = .5e3\n\n#####EVENT REPRESENTATION\nevents_times, is_pre_or_post_event = firingPattern(\n\t\t\tstart_time=start,\n\t\t\tn_pos  \t\t = data_protocol[!,:n_pos][k],\n\t\t\tdelay_pos\t = data_protocol[!,:delay_pos][k],\n\t\t\tn_pre  \t\t = data_protocol[!,:n_pre][k],\n\t\t\tdelay_pre\t = data_protocol[!,:delay_pre][k],\n\t\t\tdelay  \t\t = data_protocol[!,:delay][k],\n\t\t\tpulse  \t\t = pls,#data_protocol[:pulse][k],\t\t# PULSE\n\t\t\tfreq   \t\t = data_protocol[!,:freq][k],\t\t\t# FREQUENCY\n\t\t\tcausal \t\t = data_protocol[!,:causal][k],\n\t\t\trepeat_times = data_protocol[!,:repeat_times][k],\t# FREQUENCY\n\t\t\trepeat_after = data_protocol[!,:repeat_after][k])\n\nparam_synapse = SynapseParams(\n\t\t\tt_end\t\t   = start+(data_protocol[!,:repeat_times][k]+1)*pls*1000/data_protocol[!,:freq][k]+1.5e5,\n\t\t\tsoma_dist \t\t= 200. ,\n\t\t\ttemp_rates \t\t= data_protocol[!,:temp][k],\n\t\t\tCa_ext\t\t\t= data_protocol[!,:exca][k],\n\t\t\tMg\t\t\t\t= data_protocol[!,:exmg][k],\n\t\t\tage\t\t\t\t= data_protocol[!,:age][k],\n\t\t\tinjbap\t\t\t= data_protocol[!,:inj_time][k],\n\t\t\tI_clamp\t\t\t= data_protocol[!,:injection][k],\n\t\t\tsampling_rate   = 0.1)\n\np = param_synapse.p_release\npre_synapse = PreSynapseParams(h = (p[4]+ p[3]/(1+exp(p[1]* (data_protocol[!,:exca][k]-p[2])))))\n\nxc0 = initial_conditions_continuous_temp(param_synapse)\nxd0 = initial_conditions_discrete(param_synapse)\n\n#####RUN MODEL\nis_glu_release, Docked, Reserve, t_stp, glu_release_times, bap_by_epsp_times = stp(param_synapse.t_end, pre_synapse, events_times, is_pre_or_post_event, _plot = false, algo = CHV(CVODE_BDF()))\n@show \"number of releases $(sum(is_glu_release))\"\n\nresult = @time evolveSynapse(\n\t\txc0,\n\t\txd0,\n\t\tparam_synapse,\n\t\tevents_times[events_times .< param_synapse.t_end],\n\t\tis_pre_or_post_event,\n\t\tifelse(data_protocol[!,:AP_by_EPSP][k] == \"yes\",bap_by_epsp_times,Float64[]), #optional BaP induced by EPSP\n\t\tis_glu_release,\n\t\t# (CHV(:lsoda), CHV(:lsoda));\n\t\t(CHV(CVODE_BDF(linear_solver=:GMRES)), CHV(CVODE_BDF(linear_solver=:GMRES)));\n\t\tabstol = 1e-6, reltol = 1e-5,\n\t\tsave_positions = (false, true),\n\t\tverbose = false, progress = true) # model function\n\n\ntt = result.t\nout = SynapseElife.get_names(result.XC, result.XD)\n\nCaMKII  =  out[:KCaM0] .+ out[:KCaM2C] .+ out[:KCaM2N] .+ out[:KCaM4] .+ out[:PCaM0] .+ out[:PCaM2C] .+ out[:PCaM2N] .+ out[:PCaM4] .+ out[:P] .+ out[:P2]\nCaM\t =   out[:CaM2C] .+ out[:CaM2N] .+ out[:CaM4]\nCaN = out[:CaN4]\n\n\nargs = (color = :black, label = \"\", xlabel=\"time (s)\" ,alpha=1,w=2)\nplot!(tt/1000, CaM; subplot = 1, ylabel = \"CaM (μM)\", args...)\nplot!(tt/1000,  CaMKII;  subplot = 2, ylabel = \"CaMKII (μM)\", args...)\nplot!(tt/1000,  CaN;  subplot = 3, ylabel = \"CaN (μM)\", args...)\n","category":"page"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/#Parameters","page":"Library","title":"Parameters","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"PreSynapseParams","category":"page"},{"location":"library/#SynapseElife.PreSynapseParams","page":"Library","title":"SynapseElife.PreSynapseParams","text":"struct PreSynapseParams\n\nPresynaptic parameters\n\nFiring events are processed separately from the main simulation (at src/OnlyStp.jl) it takes the firing structure as input from the function firingPattern.\nUsing the presynaptic stimulation times, the vesicle depletion and AP induced by EPSP are estimated, however one can use a tag to deactivate it (covering sub-threshold EPSP cases) as in  dataProtocol.\nThe presynaptic part of our model is phenomenological, for instance, the variable Soma in src/OnlyStp.jl:38 was made to represent the voltage and can accumulate for faster frequencies but has an abstract unit.\n\nEquations\n\nbased on D. Sterratt et al book; Principles of Computational Modelling in Neuroscience page 183 \n\nraterec  = (R_0 - R) ⋅ τ_R ⋅ rrp \n\nraterrp  = (D_0 - D) ⋅ τ_D ⋅ rec \n\nrateref  = (R_0 - R) ⋅ ref_dt \n\nFields\n\nτ_rec: recovery constant of pre calcium decay function Default: 20000\nδ_ca: fraction of decay constant of pre calcium decay f Default: 0.0004\nτ_pre: decay time constant of pre calcium Default: 20\nτ_V: decay time constant for AP induced by EPSP Default: 40\nδ_delay_AP: delay to EPSPs onset and evoked AP Default: 15.0\nD_0: initial conditions ready releaseble pool Default: 25\nR_0: initial conditions recovery pool Default: 30\nτ_R: rate for D -> R Default: 5000\nτ_D: rate for R -> D Default: 45000\nτ_R_ref: rate for infinite reservoir -> R Default: 40000\ns: sigmoid parameter for release probability Default: 2.0\nh: sigmoid parameter for release probability Default: 0.7\nsampling_rate: sampling rate for plotting / printing Default: 1.0\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"SynapseParams","category":"page"},{"location":"library/#SynapseElife.SynapseParams","page":"Library","title":"SynapseElife.SynapseParams","text":"struct SynapseParams{Tp}\n\nPostsynaptic parameters.\n\n\n\nUnits\n\ntime: ms\nlength: µm (area µm^2, volume µm^3)\nvoltage: mV\ncurrent: pA\nconductance: nS\nresistance: GOhm\ncapacitance: pF ( ms.pA/mV = ms.nS = ms/GOhm)\nconcentration: µM\n\n\n\nFields\n\nLTP_region: Region LTP Default: VPolygon([[6.35, 1.4], [10, 1.4], [6.35, 29.5], [10, 29.5]])\nLTD_region: Region LTD Default: VPolygon([[6.35, 1.4], [6.35, 23.25], [6.35, 29.5], [1.85, 11.327205882352938], [1.85, 23.25], [3.7650354609929075, 1.4], [5.650675675675676, 29.5]])\na_D: ACTIVATION RATES FOR THRESHOLDS Default: 0.1\nb_D: Default: 2.0e-5\na_P: Default: 0.2\nb_P: Default: 0.0001\nt_D: Default: 18000\nt_P: Default: 13000\nK_D: Sigmoids controlling the rate of plasticity change Default: 80000.0\nK_P: Default: 13000.0\nrest_plstcty: Plasticity states Default: 100\nt_end: SIMULATION Default: 100\nsampling_rate: Default: 10\ntemp_rates: BIOPHYSICAL AND GHK PARAMETERS Default: 35.0\nage: Default: 60.0\nfaraday: Default: 0.096485 * 0.001\nCa_ext: Default: 2500.0\nCa_infty: Default: 0.05\ntau_ca: Default: 10.0\nD_Ca: Default: 0.3338\nf_Ca: Default: 0.1\nperm: Default: -0.04583333333333333\nz: Default: 2.0\ngas: Default: 8.314e-6\np_release: Default: (0.004225803293622208, 1708.4124496514878, 1.3499793762587964, 0.6540248201173222)\ntrec: BACKPROPAGATION ATTENUATION Default: 2000\ntrec_soma: Default: 500\ndelta_decay: Default: 1.7279e-5\np_age_decay_bap: Default: (0.13525468256031167, 16.482800452454164, 5.564691354645679)\ndelta_soma: Default: 2.5e-5 * (pagedecaybap[3] / (1 + exp(pagedecaybap[1] * (age - pagedecay_bap[2]))))\ndelta_aux: Default: 2.304e-5\ninjbap: Default: 2.0\nsoma_dist: Default: 200.0\np_dist: Default: (0.019719018173341547, 230.3206470553394, 1.4313810030893268, 0.10406540965358434)\nϕ_dist: Default: pdist[4] + pdist[3] / (1 + exp(pdist[1] * (somadist - p_dist[2])))\nI_clamp: Default: 0.0\ngamma_Na: Na and K Default: 800.0\nErev_Na: Default: 50.0\ngamma_K: Default: 40.0\nErev_K: Default: -90.0\np_nmda_frwd: NMDAr temperature modification Default: (-0.09991802053299291, -37.63132907014948, 1239.0673283348326, -1230.6805720050966)\nfrwd_T_chng_NMDA: Default: pnmdafrwd[4] + pnmdafrwd[3] / (1 + exp(pnmdafrwd[1] * (temprates - pnmda_frwd[2])))\np_nmda_bcwd: Default: (-0.10605060141396823, 98.99939433046647, 1621.6168608608068, 3.0368551011554143)\nbcwd_T_chng_NMDA: Default: pnmdabcwd[4] + pnmdabcwd[3] / (1 + exp(pnmdabcwd[1] * (temprates - pnmda_bcwd[2])))\nNMDA_N2A_ka: NMDAr kinetics (GluN2A type) Default: frwdTchng_NMDA * 34.0 * 0.001\nNMDA_N2A_kb: Default: frwdTchng_NMDA * 17.0 * 0.001\nNMDA_N2A_kc: Default: frwdTchng_NMDA * 127.0 * 0.001\nNMDA_N2A_kd: Default: frwdTchng_NMDA * 580.0 * 0.001\nNMDA_N2A_ke: Default: frwdTchng_NMDA * 2508.0 * 0.001\nNMDA_N2A_kf: Default: frwdTchng_NMDA * 3449.0 * 0.001\nNMDA_N2A_k_f: Default: bcwdTchng_NMDA * 662.0 * 0.001\nNMDA_N2A_k_e: Default: bcwdTchng_NMDA * 2167.0 * 0.001\nNMDA_N2A_k_d: Default: bcwdTchng_NMDA * 2610.0 * 0.001\nNMDA_N2A_k_c: Default: bcwdTchng_NMDA * 161.0 * 0.001\nNMDA_N2A_k_b: Default: bcwdTchng_NMDA * 120.0 * 0.001\nNMDA_N2A_k_a: Default: bcwdTchng_NMDA * 60.0 * 0.001\nNMDA_N2B_sa: NMDAr kinetics (GluN2B type) Default: frwdTchng_NMDA * 0.25 * 34.0 * 0.001\nNMDA_N2B_sb: Default: frwdTchng_NMDA * 0.25 * 17.0 * 0.001\nNMDA_N2B_sc: Default: frwdTchng_NMDA * 0.25 * 127.0 * 0.001\nNMDA_N2B_sd: Default: frwdTchng_NMDA * 0.25 * 580.0 * 0.001\nNMDA_N2B_se: Default: frwdTchng_NMDA * 0.25 * 2508.0 * 0.001\nNMDA_N2B_sf: Default: frwdTchng_NMDA * 0.25 * 3449.0 * 0.001\nNMDA_N2B_s_f: Default: bcwdTchng_NMDA * 0.23 * 662.0 * 0.001\nNMDA_N2B_s_e: Default: bcwdTchng_NMDA * 0.23 * 2167.0 * 0.001\nNMDA_N2B_s_d: Default: bcwdTchng_NMDA * 0.23 * 2610.0 * 0.001\nNMDA_N2B_s_c: Default: bcwdTchng_NMDA * 0.23 * 161.0 * 0.001\nNMDA_N2B_s_b: Default: bcwdTchng_NMDA * 0.23 * 120.0 * 0.001\nNMDA_N2B_s_a: Default: bcwdTchng_NMDA * 0.23 * 60.0 * 0.001\np_nmda: Default: (0.004477162852447629, 2701.3929349701334, 58.38819453272428, 33.949463268365555)\ngamma_nmda: Default: (pnmda[4] + pnmda[3] / (1 + exp(pnmda[1] * (Caext - p_nmda[2])))) * 0.001\np_age: Default: (0.09993657672916968, 25.102347872464193, 0.9642137892004939, 0.5075183905839776)\nr_NMDA_age: Ratio N2B/N2A Default: rand(Normal(0, 0.05)) + page[4] + page[3] / (1 + exp(page[1] * (age - page[2])))\nN_NMDA: Default: 15\nN_N2B: Default: round((NNMDA * rNMDAage) / (rNMDA_age + 1))\nN_N2A: Default: round(NNMDA / (rNMDA_age + 1))\nErev_nmda: Other NMDAr parameters Default: 0.0\nMg: Default: 1.0\np_ampa_frwd: AMPAr temperature modification Default: (-0.4737773089201679, 31.7248285571622, 10.273135485873242)\nfrwd_T_chng_AMPA: Default: pampafrwd[3] / (1 + exp(pampafrwd[1] * (temprates - pampa_frwd[2])))\np_ampa_bcwd: Default: (-0.36705555170278986, 28.976662403966674, 5.134547217640794)\nbcwd_T_chng_AMPA: Default: pampabcwd[3] / (1 + exp(pampabcwd[1] * (temprates - pampa_bcwd[2])))\nAMPA_k1: ** AMPAr kinetics  Default: frwdTchng_AMPA * 1.6 * 1.0e7 * 1.0e-6 * 0.001\nAMPA_k_1: Default: bcwdTchng_AMPA * 7400 * 0.001\nAMPA_k_2: Default: bcwdTchng_AMPA * 0.41 * 0.001\nAMPA_alpha: Default: 2600 * 0.001\nAMPA_beta: Default: 9600 * 0.001\nAMPA_delta_1: Default: 1500 * 0.001\nAMPA_gamma_1: Default: 9.1 * 0.001\nAMPA_delta_2: Default: 170 * 0.001\nAMPA_gamma_2: Default: 42 * 0.001\nAMPA_delta_0: Default: 0.003 * 0.001\nAMPA_gamma_0: Default: 0.83 * 0.001\ngamma_ampa1: AMPAr conductances Default: 0.5 * 0.031\ngamma_ampa2: Default: 0.5 * 0.052\ngamma_ampa3: Default: 0.5 * 0.073\nN_ampa: Default: 120\nErev_ampa: Default: 0.0\nN_GABA: GABAr Default: 34\np_Cl: Default: (0.09151696057098718, 0.6919298240788684, 243.5159017060495, -92.6496083089155)\nErev_Cl: GABAr, Cl reversal potential Default: pCl[4] + pCl[3] / (1 + exp(pCl[1] * (age - pCl[2])))\ngamma_GABA: Default: 0.035\nGABA_r_b1: Default: 1.0e6 * 1.0e-6 * 0.001 * 20\nGABA_r_u1: Default: 1000.0 * 0.0046\nGABA_r_b2: Default: 1.0e6 * 1.0e-6 * 0.001 * 10\nGABA_r_u2: Default: 1000.0 * 0.0092\nGABA_r_ro1: Default: 1000.0 * 0.0033\nGABA_r_ro2: Default: 1000.0 * 0.0106\np_GABA: Default: (0.19127068198185954, 32.16771140618756, -1.2798050197287802, 1.470692263981145)\nGABA_r_c1: Default: (pGABA[4] + pGABA[3] / (1 + exp(pGABA[1] * (temprates - p_GABA[2])))) * 1000.0 * 0.0098\nGABA_r_c2: Default: (pGABA[4] + pGABA[3] / (1 + exp(pGABA[1] * (temprates - p_GABA[2])))) * 0.4\nE_leak: Passive electrical properties Default: -70.0\ng_leak: Default: 4.0e-6\nCm: Default: 0.006\nR_a: Default: 0.01\nD_dend: ** MORPHOLOGY: Dendritic properties** Default: 2.0\nL_dend: Default: 1400\nA_dend: Default: 2 * pi * (Ddend / 2) * Ldend\nVol_dend: Default: pi * (Ddend / 2) ^ 2 * Ldend\nCdend: Default: Cm * A_dend\nCS_dend: Default: pi * (D_dend / 2) .^ 2\ng_leakdend: Default: gleak * Adend\nD_soma: MORPHOLOGY: Soma properties Default: 30\nA_soma: Default: pi * D_soma ^ 2\nCsoma: Default: Cm * A_soma\nCS_soma: Default: pi * (D_soma / 2) .^ 2\ng_leaksoma: Default: 15.0\ng_diff: Default: Ddend / (4Ra)\nVol_sp: Spine properties Default: 0.03\nA_sp: Default: 4 * pi * ((3Vol_sp) / (4pi)) ^ (2.0 / 3.0)\nCsp: Default: Cm * A_sp\ng_leaksp: Default: gleak * Asp\nD_neck: Neck properties Default: 0.1\nL_neck: Default: 0.2\nCS_neck: Default: pi * (D_neck / 2) .^ 2\ng_neck: Default: CSneck / (Lneck * R_a)\ntau_diff: Default: Volsp / (2 * DCa * Dneck) + Lneck ^ 2 / (2D_Ca)\nglu_width: SYNAPTIC GLUTAMATE TRANSIENT PARAMETERS Default: 1.0\nglu_amp: Default: 1000.0\nglu_cv: Default: 0.5\nN_SK: SK channels Default: 15\nSK_gamma: Default: 0.01\nSK_Erev: Default: -90\nSK_gating_half: Default: 0.33\nSK_time: Default: 6.3\nSK_hill: Default: 6\np_SK_bcwd: Default: (0.09391588258147192, 98.85165844770867, -147.61669527876904, 149.37767054612135)\nbcwd_SK: Default: pSKbcwd[4] + pSKbcwd[3] / (1 + exp(pSKbcwd[1] * (temprates - pSK_bcwd[2])))\np_SK_frwd: Default: (-0.334167923607112, 25.590920461511878, 2.2052151559841193, 0.005904170174699533)\nfrwd_SK: Default: pSKfrwd[4] + pSKfrwd[3] / (1 + exp(pSKfrwd[1] * (temprates - pSK_frwd[2])))\nCaM_con: **Concentrations Default: 30.0\nmKCaM_con: Default: 70.0\nmCaN_con: Default: 20.0\nkon_1C: Chang Pepke model - CaM reactions I Default: 0.005\nkoff_1C: Default: 0.05\nkon_2C: Default: 0.01\nkoff_2C: Default: 0.01\nkon_1N: Default: 0.1\nkoff_1N: Default: 2.0\nkon_2N: Default: 0.2\nkoff_2N: Default: 0.5\nkf_CaM0: Chang Pepke model - CaM reactions II Default: 3.8e-6\nkb_CaM0: Default: 0.0055\nkf_CaM2C: Default: 0.00092\nkb_CaM2C: Default: 0.0068\nkf_CaM2N: Default: 0.00012\nkb_CaM2N: Default: 0.0017\nkf_CaM4: Default: 0.03\nkb_CaM4: Default: 0.0015\nkon_K1C: Chang Pepke model - CaMKII reactions Default: 0.044\nkoff_K1C: Default: 0.033\nkon_K2C: Default: 0.044\nkoff_K2C: Default: 0.0008\nkon_K1N: Default: 0.076\nkoff_K1N: Default: 0.3\nkon_K2N: Default: 0.076\nkoff_K2N: Default: 0.02\np_camkii_q10: Chang Pepke model - autophosphorilation Default: (0.5118207068695309, 45.47503600542303, -161.42634157226917, 162.1718925882677)\nq10: Default: pcamkiiq10[4] + pcamkiiq10[3] / (1 + exp(pcamkiiq10[1] * (temprates - pcamkii_q10[2])))\nk1: Default: 0.0126\nk2: Default: q10 * 0.00033\nk3: Default: 4 * q10 * 0.00017\nk4: Default: 4 * 4.1e-5\nk5: Default: 4 * q10 * 2 * 1.7e-5\np_CaN_frwd: CaM-CaN reactions Default: (-0.29481489145354556, 29.999999999999968, 0.15940019940354327, 0.870299900298228)\nkcanf: Default: (pCaNfrwd[4] + pCaNfrwd[3] / (1 + exp(pCaNfrwd[1] * (temprates - pCaN_frwd[2])))) * 0.0175\np_CaN_bcwd: Default: (-0.6833299932488973, 26.277500129849113, 0.7114524682690591, 0.29037766196937326)\nkcanb: Default: (pCaNbcwd[4] + pCaNbcwd[3] / (1 + exp(pCaNbcwd[1] * (temprates - pCaN_bcwd[2])))) * 2.0e-5\np_frwd_VGCC: VGCCs Default: (1.0485098341579628, 30.66869198447378, -0.3040010721391852, 2.5032059559264357)\nfrwd_VGCC: Default: pfrwdVGCC[4] + pfrwdVGCC[3] / (1 + exp(pfrwdVGCC[1] * (temprates - pfrwd_VGCC[2])))\np_bcwd_VGCC: Default: (-0.3302682317933842, 36.279019647221226, 3.2259761593440155, 0.7298285671937866)\nbcwd_VGCC: Default: pbcwdVGCC[4] + pbcwdVGCC[3] / (1 + exp(pbcwdVGCC[1] * (temprates - pbcwd_VGCC[2])))\nErev_CaT: Default: 10.0\nErev_CaR: Default: 10.0\nErev_CaL: Default: 10.0\ngamma_CaT: Default: 0.012\ngamma_CaR: Default: 0.017\ngamma_CaL: Default: 0.027\nN_caT: Default: 3\nN_caR: Default: 3\nN_caL: Default: 3\nEGTA_kf: Calcium dye and buffers Default: 0.0027\nEGTA_kb: Default: 0.18 * EGTA_kf\nEGTA_con: Default: 0.0\nBAPTA_kf: Default: 0.45\nBAPTA_kb: Default: 0.176BAPTA_kf\nBAPTA_con: Default: 0.0\nImbuf_k_on: Default: 0.247\nImbuf_k_off: Default: 0.524\nK_buff_diss: Default: Imbufkoff / Imbufkon\nImbuf_con: Default: 62\nImbuf_con_dend: Default: Imbuf_con * 4\nogb1_kf: Calcium fluorescent dyes Default: 0.8\nogb1_kb: Default: 0.16\nfluo4_kf: Default: 0.8\nfluo4_kb: Default: 0.24\ndye: Default: 0.0\nfluo5f_kf: Default: dye * 0.01\nfluo5f_kb: Default: dye * 26 * fluo5f_kf\nfluo5f_con: Default: dye * 200.0\n\n\n\n\n\n","category":"type"},{"location":"library/#Protocols","page":"Library","title":"Protocols","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"firingPattern","category":"page"},{"location":"library/#SynapseElife.firingPattern","page":"Library","title":"SynapseElife.firingPattern","text":"firingPattern(\n;\n    start_time,\n    n_pre,\n    delay_pre,\n    n_pos,\n    delay_pos,\n    delay,\n    pulse,\n    freq,\n    causal,\n    repeat_times,\n    repeat_after\n)\n\n\nCompute external stimulation times and indices for pre/post stimulation. Usually used with dataProtocol (see folder examples in examples/).\n\nOutput\n\nevent_times sorted list of external event times\nis_pre_or_post_index whether the external events are pre (true) or post (false)\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"dataProtocol","category":"page"},{"location":"library/#SynapseElife.dataProtocol","page":"Library","title":"SynapseElife.dataProtocol","text":"dataProtocol(paper)\n\n\nStructure to describe a plasticity protocol\n\nArguments\n\nn_pre number of presynaptic pulses\ndelay_pre delay between presynaptic pulses\nn_pos number of postsynaptic pulses\ndelay_pos delay between postsynaptic pulses\ndelay delay between pre and postsynaptic spikes (used in STDP)\npulse number of pulses/pairing repetitions\nfreq frequency\ncausal causal inverts the order of pre and post, uses true or false\nprotocol name of the protocol\nweight info entry with weight change value (not used in the model)\noutcome String to show the qualitative outcome (not used in the model)\npaper paper is a String to choose a predefined protocol (e.g. paper = TigaretMellor16)\ntemp temperature by which all temperature-sensitive mechanisms will be adapted\ninjection (nA) current injected in the soma, used to make postsynaptic spikes (BaPs)\nexca (μM) extracellular calcium, we expressed it in μM to be used in the ghk function\nexmg (mM) extracellular magnesium, we expressed it in mM, however, it is converted to μM in the magnesium relief function\nrepeat_times number of epochs additional epochs to include, for instance, TBS is usually expressed in epochs\nrepeat_after time difference between the epochs (ms)\ntesting_freq some protocols use test frequencies, this can be useful to evaluate the effect or absence of it, or to add a regular background presynaptic stimuli. 0 Hz will turn it off\ninj_time duration (ms) of the current injection to elicit a BaP\nage animal age (rat)\nAP_by_EPSP yes or no, to let additional BaPS induced by EPSPs to be included in the stimulation\nGABA_block yes or no GABAr conductance is set zero\njitter standard deviation of a Gaussian used to jitter the spikes\nsparse percentage of spikes skipped\ndista distance from the soma in μm\n\n\n\n\n\n","category":"function"},{"location":"library/#Pre-synaptic-simulation","page":"Library","title":"Pre-synaptic simulation","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"stp","category":"page"},{"location":"library/#SynapseElife.stp","page":"Library","title":"SynapseElife.stp","text":"stp(\n    t_end,\n    param,\n    all_events_times,\n    is_pre_or_post_index;\n    _plot,\n    nu_stp,\n    kwargs...\n)\n\n\nThis function performs the simulation of the presynaptic side.\n\nArguments:\n\nt_end end of simulation time\nparam named tuple with parameters, example: (τ_rec = 20000, δ_decay\t= .0004, tau_pre = 20, tau_soma = 40)\nall_events_times sorted list of times of external events\nis_pre_or_post_index whether the external events are pre (true) or post (false)\n\nKeyword arguments\n\n_plot = false whether to plot the result or not\nnu_stp = stp_build_transition_matrix() transition matrix\n\nOutput\n\nis_glu_release true (success) or false (failure), list of presynaptic stimuli in all_events_index that led to a vesicle (glutamate) release\nD, also (XD[2,:]), the evolution of the docked pool\nR, also (XD[3,:]), the evolution of the reserve pool\ntime simulation times\nglu_release_times the vector of times in which a successful releases (glutamate) occurred\nbap_by_epsp_times the vector of times in which an AP was triggered by an EPSP\n\n\n\n\n\n","category":"function"},{"location":"library/#Post-synaptic-simulation","page":"Library","title":"Post-synaptic simulation","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"evolveSynapse","category":"page"},{"location":"library/#SynapseElife.evolveSynapse","page":"Library","title":"SynapseElife.evolveSynapse","text":"evolveSynapse(\n    xc0,\n    xd0,\n    p_synapse,\n    events_sorted_times,\n    is_pre_or_post_event,\n    bap_by_epsp,\n    is_glu_released,\n    algos;\n    verbose,\n    progress,\n    abstol,\n    reltol,\n    save_positions,\n    nu,\n    kwargs...\n)\n\n\nPerform a simulation of the synapse model. Among other things, you need to provide the external events impacting the synapse: Glutamate releases and BaPs.\n\nArguments\n\nxc0 initial condition for the continuous variables. Example xc0 = Synapse.initial_conditions_continuous_temp(p_synapse)\nxd0 initial condition for the discrete variables. Example xd0 = Synapse.initial_conditions_discrete(p_synapse)\np_synapse::SynapseParams synapse parameters. Example p_synapse = SynapseParams().\nevents_sorted_times sorted list of times (ms) for external events (Glutamate / BaP)\nis_pre_or_post_event::Vector{Bool} whether the corresponding event in events_sorted_times is a Glutamate event. If false, it corresponds to a BaP event.\nbap_by_epsp::Vector{<:Real} Additionnal BaPs time events, these are evoked by EPSPs. There are added to the ones indexed in is_events_glu.\nis_glu_released::Vector{Bool} variable to shut down the Glutamate event, i.e. make the glutamate amplitude be zero. This proves useful to have this variable for reproducing some experiments. If equals to false, then glutamate amplitude is set to zero.\nalgos simulation algorithms from PiecewiseDeterministicMarkovProcesses. For example (PDMP.CHV(:lsoda), PDMP.CHV(:lsoda))\n\nOptional arguments\n\nverbose = false display information during simulation\nabstol = 1e-8 absolute tolerance for ODE time stepper\nreltol = 1e-7 relative tolerance for ODE time stepper\nprogress = false show a progressbar during simulation\nsave_positions = (false, true) save the values (before, after) the jumps (transitions)\nnu transition matrix. It is initialised with buildTransitionMatrix().\n\n\n\n\n\n","category":"function"},{"location":"library/#Utils","page":"Library","title":"Utils","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"SynapseElife.statistics_jumps","category":"page"},{"location":"library/#SynapseElife.statistics_jumps","page":"Library","title":"SynapseElife.statistics_jumps","text":"Returns the number of jumps for each component and t ∈ stpan. Usefull to determine who jumps the most. The syntax is as follows\n\nstatistics_jumps(t, xd; tspan)\n\n\nwhere t is time, xd the discrete component and It is an inferior bound on t. You can use it like\n\nstatistics_jumps(t, out[:ampa])\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"SynapseElife.get_names","category":"page"},{"location":"library/#SynapseElife.get_names","page":"Library","title":"SynapseElife.get_names","text":"Returns a dictionary out from a simulation with associated names like out[:ampa]. Use it like\n\nget_names(xc, xd)\n\n\nAnother use is for plotting.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"SynapseElife.plot_variable","category":"page"},{"location":"library/#SynapseElife.plot_variable","page":"Library","title":"SynapseElife.plot_variable","text":"plot_variable(tt, xc, xd)\nplot_variable(tt, xc, xd, s; tspan, kwargs...)\n\n\nPlotting function\n\nArguments\n\ntt times\nxc continuous variable\nxd discrete variable\ns::Symbol = :ampa which variable to plot. Must be :ampa, :nmda, :vgcc_t, :vgcc_r, :vgcc_l or :Vsp,:Vdend,:Vsoma,:λ,:ImbufCa,:Ca,:Dye,:CaM0,:CaM2C,:CaM2N,:CaM4,:mCaN,:CaN4,:mKCaM,:KCaM0,:KCaM2N,:KCaM2C,:KCaM4,:PCaM0,:PCaM2C,:PCaM2N,:PCaM4,:P,:P2,:LTD,:LTP,:LTD_act,:LTP_act,:m,:h,:n,:SK,:λ_age,:λ_aux.\n\nOptional arguments\n\nall arguments from Plots.jl. For example xlims=(0,10), legend=false\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"SynapseElife.plot_discrete","category":"page"},{"location":"library/#SynapseElife.plot_discrete","page":"Library","title":"SynapseElife.plot_discrete","text":"plot_discrete(tt, xc, xd; tspan, kwargs...)\n\n\nPlot all discrete variables.\n\nArguments\n\ntt times\nxc continuous variables (result from PDMP)\nxd discrete variables (result from PDMP)\n\nOptional arguments\n\nall arguments from Plots.jl. For example xlims = (0, 10), legend = false\n\n\n\n\n\n","category":"function"},{"location":"library/#Automatic-Code-generation","page":"Library","title":"Automatic Code generation","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"SynapseElife.extractReactionsCamKII","category":"page"},{"location":"library/#SynapseElife.extractReactionsCamKII","page":"Library","title":"SynapseElife.extractReactionsCamKII","text":"extractReactionsCamKII()\nextractReactionsCamKII(filename)\n\n\nThis function extracts the differential equations from the CaM-CaMKII-CaN reactions and write it into the file with name filename = \"write-equation.txt\". The outcome of this function is used to write the F_synapse.\n\n\n\n\n\n","category":"function"},{"location":"#SynapseElife.jl","page":"Home","title":"SynapseElife.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the main repository for the Synapse simulation package written in Julia language. The associated publication is here on BiorXiv.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To run the package SynapseElife, we need some bleeding edge versions of other packages.","category":"page"},{"location":"#Installation-from-website","page":"Home","title":"Installation from website","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package, please run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add PiecewiseDeterministicMarkovProcesses#master\npkg> add https://github.com/rveltz/SynapseElife.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can then use it like","category":"page"},{"location":"","page":"Home","title":"Home","text":"using SynapseElife","category":"page"},{"location":"#Packages-for-Figure1-and-Figure2","page":"Home","title":"Packages for Figure1 and Figure2","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following packages must be installed (only once) to run examples/Figure1.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Revise Random Plots ColorSchemes Parameters","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following packages must be installed (only once) to run examples/Figure2.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Revise Random Plots ColorSchemes Parameters","category":"page"}]
}
